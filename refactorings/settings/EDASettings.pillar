! Introduction

Currently, only one PharoEDA application can be running in a Pharo image.

A ==EDAApplication== has configurable properties, that can be inspected and modified using ==SettingBrowser==.
The ==SettingBrowser== customization is done in ==EDASettings== class, using the ==<systemsettings>== pragma, which requires the method to be on the class side.
Since that method expects a class and accessors to inspect and modify each setting, a simple approach might just consist of using specific classes, not instances, directly. The main benefit of this approach is to make ==EDASettings== unaware of the existence of the ==EDAApplication== class. However, this only applies on the surface, because both classes know which classes contain the setting values.

Additionally, the configuration settings are read from a json file, which gets identified by an environment variable. But that file is only used for the initial values, and its contents are not synchronized with the values of the application after they are modified using ==SettingBrowser==. Ideally, each setting could be managed differently: either from an environment variable, from a json file, or manually.

! Motivation

On one hand, to avoid using classes as setting containers, and sharing them between ==EDASettings== and ==EDAApplication==.
On the other hand, to be able to manage more than one ==EDAApplication== instance. Every instance should have its own settings, and its own subtree in ==SettingBrowser==.
Finally, abstract the holder of each setting so the actual value can be obtained from different sources.

! Application registry

We need a way to know which ==EDAApplication== instances exist, and a way to interact with them. A simple registry is enough for now.

Let's start by creating the class, with a ""registry"" attribute we'll use to annotate the references to the existing applications.

[[[
Object subclass: #EDAApplications
  uses: EDATLogging
  instanceVariableNames: 'registry'
  classVariableNames: ''
  package: 'EDA-Application'
]]]

The ""registry"" should be accessed via dedicated methods, under the ''accessing'' protocol.

${changes:01-EDAApplications_registry_.ombu}$
${changes:02-EDAApplications_registry.ombu}$

We'll throw a ==EDAApplicationAlreadyRegistered== exception in case the application is already registered.

[[[
Error subclass: #EDAApplicationAlreadyRegistered
  instanceVariableNames: ''
  classVariableNames: ''
  package: 'EDA-Application'
]]]

Now we can implement a method to register applications. We'll identify each application by its name.

${changes:03-EDAApplications_register_under_.ombu}$

To make the API simpler, let's add a new method in ==EDAApplications==:
${changes:04-EDAApplications_register_.ombu}$


Now each application needs a name, but it could be optional at instance-level. We'd like to omit the instance name if only one instance will ever be created. In other words, an instance can have its own name, but can rely upon the class'.

We need to add the new attribute to ==EDAApplication==:

[[[
Object subclass: #EDAApplication
  uses: EDATLogging
  instanceVariableNames: 'applicationName eventStore eventAnnouncer commandConsumer commandDispatcher eventProducer commandListenerClientDebug isConfigured isStarted projectorsByTenant projectionSynchronizationEnabled'
  classVariableNames: 'ProjectionSynchronizationEnabled'
  package: 'EDA-Application'
]]]

The following accessors deal with that:

${changes:05-EDAApplication_applicationName.ombu}$
${changes:06-EDAApplication_applicationName_.ombu}$

We'll delegate on the class itself to provide a default name.

${changes:07-EDAApplication_class_applicationName.ombu}$

Now that every application instance has a name, and it's used to reference the application in the registry, we should provide a way to inspect the applications already registered:

${changes:08-EDAApplications_edaApplications.ombu}$

Recall that ==EDAApplication== was previously meant to be used as a class, not to create instances. It might be useful to guide developers on how to create new instances. If they use ""new"" and forget to provide a name, they'll end up with unnamed applications, and won't be able to register more than one in the registry. Therefore, we'll miss precisely the point we're trying to make.

This factory method (class-side) ensures the instances are created with a name. Notice we don't use ""self new"". We're dealing with that soon enough.

${changes:09-EDAApplication_class_withName.ombu}$

Analogously, we can create "unnamed" instances as well.

${changes:10-EDAApplication_class_unnamed.ombu}$

However, instances can be created without a name (being "unnamed"). If we want to ensure instances are created via the factory methods above, we can override the ""new"" method.

${changes:11-EDAApplication_class_new.ombu}$

We'd need to convert ==EDAApplications== into a singleton, to ensure there's only one registry of running applications. To do so, we add a ""uniqueInstance"" attribute on the class itself.
[[[
Object subclass: #EDAApplications
  uses: EDATLogging
  instanceVariableNames: 'registry'
  classVariableNames: 'uniqueInstance'
    package: 'EDA-Application'
]]]

Again, we use a lazy approach in the getter:

${changes:12-EDAApplications_class_uniqueInstance.ombu}$

  We use a trivial setter.

${changes:13-EDAApplications_class_uniqueInstance_.ombu}$

Finally, we can create applications and register them.

[[[
EDAApplications uniqueInstance register: (EDAApplication withName: 'test-1')
]]]

And  inspect the registered applications as well.

[[[
EDAApplications uniqueInstance edaApplications
]]]
! Automatic registration of EDAApplications

At the expense of introducing a cyclic coupling between ==EDAApplication== and ==EDAApplications== classes, it's convenient to make sure all ==EDAApplication== instances get registered automatically.

${changes:14-EDAApplication_class_withName_.ombu}$
! Different subtrees for each application

In ==EDASettings== we need to build subtrees dynamically, based on the already registered applications.
We can create a new entry using the ""group:"" method of the ==SettingTreeBuilder== that is passed to the ==<systemsettings>==-tagged method: ==aBuilder group: #subtreeSymbol==

We need to ensure ==#subtreeSymbol== is unique. Otherwise the subtree will be created under an existing entry.

Let's remove the current ==<systemsettings>== pragma of ==EDASettings class>>edaSettingsOn:== and rename it to ==EDASettings class>>edaSettingsOn: aBuilder for: anEDAApplication under: aSymbol==, and let's write a new ==EDASettings class>>edaSettingsOn:== from scratch.

Since we haven't created (or registered) any application yet, we can choose either to skip creating anything, or display a message.

${changes:15-EDASettings_class_edaSettingsOn_.ombu}$

However, the old ""edaSettings:"" method used a fixed symbol to place the application settings in the tree. Let's fix that. We'll start with the ==environmentSettingsOn:under:on:==. The rest of the methods will be fixed later.

${changes:16-EDASettings_class_edaSettingsOn_for_under_.ombu}$

As you can see, we've renamed the previous method from ""environmentSettingsOn: aBuilder under: aSymbol"" to ""environmentSettingsOn: aBuilder: under: aSymbol on: anEDAApplication"". To display and manage each application's settings, we need the application instance. Previously, we used class-scoped attributes of predefined classes as settings. Now we're going to access them through the application instance itself.
We need to create the ==config/== folder and two files (""development.json"" and ""integration-tests.json"")  with an initial empty json file (=={}==) in them.

Additionally, we'll comment some settings code in ==EDATestSettings== class as well. We'll deal with it later.
${changes:17-EDATestSettings_class_edaTestSettingsOn_.ombu}$
! Ports and adapters

We might just add the settings as instance attributes of the ==EDAApplication== itself. Such solution would not be flexible enough.
To accomodate different implementations, we can abstract them as a Port. ==EDAApplication== instances will include a reference to a port, regardless of the actual implementation used.

The required ports are: environment, command listener, event publisher, event store, projections, and logging.

!! Minimal behavior shared among all  Settings Ports

Even though in Smalltalk there's no such thing as an interface (a definition of the contract exposed by all implementations), we'd like to ensure all adapters share certain behavior. For that, we'll use a trait.

[[[
Trait named: #EDATSettingsPort
  uses: {}
  package: 'EDA-Settings-Ports'
]]]

The most basic behavior all adapters should support is telling us a brief description of themselves.

${changes:18-EDATSettingsPort_classTrait_description.ombu}$
! Environment setting

This setting is used to identify the environment. Currently, it shows the value of the ""PHARO_ENV"" environment variable. The first adapter would be one that supports this feature.

If we inspect the current logic used in ==EDASettings== to inject the environment setting into de ==SettingBrowser== tree, we see the following:

${changes:19-EDASettings_class_environmentSettingsOn_under_on_.ombu}$

The nature of this setting is to choose one of the available environment. It's mainly informative, but it might impose certain restrictions or influence other settings as well.
!! Environment variable adapter

As its value is provided by the ""PHARO_ENV"" environment variable, it cannot be changed. We'll change the ""pickOne:"" above with a simple label, as we did before, when there're no registered applications.

[[[
Object subclass: #EDAEnvironmentSettingsEnvVarAdapter
  uses: EDATSettingsPort
  instanceVariableNames: ''
  classVariableNames: ''
  package: 'EDA-Settings-Adapters-EnvVars'
]]]

Now we need to distinguish between the case in which the value is a single string, and the previous assumption that it'd always be a list of items. A simple way to accomplish it is to ask the port itself. Remember that ==EDASettings== relies on ==EDAApplication== to provide the settings, and the latter only deals with ports, not adapters. It makes sense to create a new custom ==EDATSettingsPort== specifically for the environment-related adapters.

[[[
Trait named: #EDATEnvironmentSettingsPort
  uses: EDATSettingsPort
  package: 'EDA-Settings-Ports'
]]]

Of course, we'll use that trait in our current adapter instead of the generic one we were using.

[[[
Object subclass: #EDAEnvironmentSettingsEnvVarAdapter
  uses: EDATEnvironmentSettingsPort
  instanceVariableNames: ''
  classVariableNames: ''
  package: 'EDA-Settings-Adapters-EnvVars'
]]]

This variation can now be accomodated in the new ==EDATEnvironmentSettingsPort==.

${changes:20-EDATEnvironmentSettingsPort_supportsMultiple.ombu}$

Now, ==EDASettings== can include both variations:

${changes:21-EDASettings_class_environmentSettingsOn_under_on_.ombu}$

==EDAApplication== has to provide an adapter for its ""environmentSettingsPort"" somehow. We'll deal with a mechanism to choose from a list of available adapters soon. For now, let's return the one we've just implemented: ==EDAEnvironmentSettingsEnvVarAdapter==.

[[[
Object subclass: #EDAApplication
  uses: EDATLogging
  instanceVariableNames: 'applicationName commandConsumer commandDispatcher commandListenerClientDebug environmentSettingsPort eventAnnouncer  eventProducer eventStore isConfigured isStarted projectorsByTenant projectionSynchronizationEnabled'
  classVariableNames: 'ProjectionSynchronizationEnabled'
  package: 'EDA-Application'.
]]]

${changes:22-EDAApplication_environmentSettingsPort.ombu}$


${changes:23-EDAApplication_environmentSettingsPort_.ombu}$


When we launch a ==SettingBrowser== we get an ==SubclassResponsibility== error. Let's implement it in our adapter. But does it support a list of values? Actually, no. We cannot change the value of the environment value.

${changes:24-EDAEnvironmentSettingsEnvVarAdapter_supportsMultiple.ombu}$

Running again ==SettingBrowser== will try to call ""currentEnvironment"" on our adapter, but we haven't implemented  it yet. Let's do it now.

${changes:25-EDAEnvironmentSettingsEnvVarAdapter_currentEnvironment.ombu}$

==SettingBrowser== should render the tree now, but we're not done yet with this adapter. ==EDASettings== assumes the setting can be customized. That is, the adapter supports setting a new value. How can we make it read-only? First of all, ==EDASettings== mustn't make any assumption. It's responsibility of the port to provide that information.

So if the port's ""isReadOnly"" returns ""true"", then ==EDASettings== will use a ==LabelMorph== to display the value provided by the port itself.

We're implementing the ports as traits. It makes sense to indicate all adapters need to override this method.

${changes:26-EDATEnvironmentSettingsPort_isReadOnly.ombu}$

Our adapter clearly needs to return ""true"":

${changes:27-EDAEnvironmentSettingsEnvVarAdapter_isReadOnly.ombu}$


All adapters will share the same entry in ==SettingsBrowser==. We'll define that label in ==EDATEnvironmentSettingsPort=='s ""description"":

${changes:28-EDATEnvironmentSettingsPort_classTrait_description.ombu}$


Based on the port and adapter's metadata, ==EDASettings== will choose how to properly display the entry it the tree.


${changes:29-EDASettings_class_environmentSettingsOn_under_on_.ombu}$

!!! Refactoring

Even though our adapter is working, it's not reusable. Every other setting whose value comes from an environment variable would need to share most of its behavior. Before continuing with the next adapter, let's refactor this a bit.

First, let's extract the logic to retrieve values from environment variables into its own trait.

[[[
Trait named: #EDATEnvVarAdapter
  uses: EDATSettingsPort
  package: 'EDA-Settings-Adapters-EnvVars'
]]]

[[[
    EDATEnvVarAdapter
      compile: '
    getValueFor: envVarName orElse: defaultValue
^ OSPlatform current environment
    at: envVarName
    ifAbsent: defaultValue
'
      classified: 'environment-settings'
]]]

[[[
    EDATEnvVarAdapter
      compile: '
  supportsMultiple
    ^ false
'
    classified: 'testing'

]]]

[[[
    EDATEnvVarAdapter
      compile: '
  isReadOnly
    ^ true
'
      classified: 'testing'
]]]

Our adapter now uses this new trait instead of ==EDATSettingsPort==:
[[[
Object subclass: #EDAEnvironmentSettingsEnvVarAdapter
  uses: EDATEnvVarAdapter
  instanceVariableNames: ''
  lassVariableNames: ''
  package: 'EDA-Settings-Adapters-EnvVars'
]]]

Finally, the ""currentEnvironment"" implementation delegates the logic to the new trait:

[[[
    EDAEnvironmentSettingsEnvVarAdapter
      compile: '
    currentEnvironment
^ self
    getValueFor: 'PHARO_ENV'
    orElse: '(PHARO_ENV not set)'
'
      classified: 'environment'
]]]

!! Predefined list adapter

This adapter allows the user to choose among a predefined list of possible values for the environment setting.
From the point of view of ==EDASettings==, if the port supports multiple values, it needs to provide them in advance.

[[[
EDASettings class
      compile: '
environmentSettingsOn: aBuilder under: aParent on: app
  | entry port |
  port := app environmentSettingsPort.
  (port supportsMultiple)
    ifTrue: [ entry := aBuilder pickOne: #currentEnvironment.
      entry
        domainValues:
          (port availableEnvironments
            collect: [ :level | level translated -> level greaseString ]) ]
    ifFalse: [ (port isReadOnly)
      ifTrue: [ entry := aBuilder group: #currentEnvironment.
        entry dialog: [ LabelMorph newLabel: port currentEnvironment ] ]
      ifFalse: [ entry := aBuilder setting: #currentEnvironment ]
    ].
  entry
    parent: aParent;
    target: aConfig;
    label: aString translated;
    description: aDescription;
    order: 1
'
    classified: 'settings'
]]]

For the new adapter, let's create a new package ==EDA-Settings-Adapters-InMemory== first.

[[[
Object subclass: #EDAPredefinedEnvironmentSettingsInMemoryAdapter
  uses: EDATEnvironmentSettingsPort
  instanceVariableNames: 'currentEnvironment'
  classVariableNames: ''
  package: 'EDA-Settings-Adapters-InMemory'
]]]

 It needs to store the selected value in memory.

[[[
EDAPredefinedEnvironmentSettingsInMemoryAdapter
      compile: '
currentEnvironment
  ^ currentEnvironment ifNil: [ self availableEnvironments first ]
'
      classified: 'accessing'
]]]

[[[
EDAPredefinedEnvironmentSettingsInMemoryAdapter
      compile: '
currentEnvironment: aByteString
  currentEnvironment := aByteString
'
    classified: 'accessing'
]]]

The list of predefined values is provided by the ""availableEnvironments"" method, used also by ==EDASettings==:

[[[
EDAPredefinedEnvironmentSettingsInMemoryAdapter
      compile: '
availableEnvironments
  ^ OrderedCollection with: 'dev' with: 'test' with: 'PRO'
'
      classified: 'accessing'
]]]

We need to tell that the new adapter supports multiple values, so ==EDASettings== uses ""pickOne:"" to render the setting.

[[[
EDAPredefinedEnvironmentSettingsInMemoryAdapter
      compile: '
    supportsMultiple
  ^ true
'
      classified: 'testing'
]]]

Also, even though now it's not strictly necessary, this adapter supports read-write values, in case anyone needs to know it.

[[[
EDAPredefinedEnvironmentSettingsInMemoryAdapter
      compile: '
    isReadOnly
  ^ false
'
      classified: 'testing'
]]]

Finally, to test it we can just change ==EDAApplication== to use it instead of the current one. We'll introduce a mechanism to inject adapters into ports dynamically soon.

[[[
EDAApplication
      compile: '
environmentSettingsPort
  | result |
  result := environmentSettingsPort.
  result ifNil: [
    result := EDAPredefinedEnvironmentSettingsInMemoryAdapter new.
    self environmentSettingsPort: result
  ].
  ^ result
'
    classified: 'accessing'
]]]

!!! Refactoring

As we did with the environment-variable adapter, let's introduce a new intermediary trait, common to all "in-memory" adapters, to indicate ""isReadOnly"" is by default ""false"".

[[[
Trait named: #EDATInMemoryAdapter
  uses: EDATSettingsPort
  package: 'EDA-Settings-Adapters-InMemory'
]]]

[[[
Object subclass: #EDAPredefinedEnvironmentSettingsInMemoryAdapter
  uses: EDATInMemoryAdapter
  instanceVariableNames: 'currentEnvironment'
  classVariableNames: ''
  package: 'EDA-Settings-Adapters-InMemory'
]]]
