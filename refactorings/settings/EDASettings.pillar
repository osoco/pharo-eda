! Introduction

Currently, only one PharoEDA application can be running in a Pharo image.

A ==EDAApplication== has configurable properties, that can be inspected and modified using ==SettingBrowser==.
The ==SettingBrowser== customization is done in ==EDASettings== class, using the ==<systemsettings>== pragma, which requires the method to be on the class side.
Since that method expects a class and accessors to inspect and modify each setting, a simple approach might just consist of using specific classes, not instances, directly. The main benefit of this approach is to make ==EDASettings== unaware of the existence of the ==EDAApplication== class. However, this only applies on the surface, because both classes know which classes contain the setting values.

Additionally, the configuration settings are read from a json file, which gets identified by an environment variable. But that file is only used for the initial values, and its contents are not synchronized with the values of the application after they are modified using ==SettingBrowser==. Ideally, each setting could be managed differently: either from an environment variable, from a json file, or manually.

! Motivation

On one hand, to avoid using classes as setting containers, and sharing them between ==EDASettings== and ==EDAApplication==.
On the other hand, to be able to manage more than one ==EDAApplication== instance. Every instance should have its own settings, and its own subtree in ==SettingBrowser==.
Finally, abstract the holder of each setting so the actual value can be obtained from different sources.

! Application registry

We need a way to know which ==EDAApplication== instances exist, and a way to interact with them. A simple registry is enough for now.

Let's start by creating the class, with a ""registry"" attribute we'll use to annotate the references to the existing applications.

[[[
Object subclass: #EDAApplications
  uses: EDATLogging
  instanceVariableNames: 'registry'
  classVariableNames: ''
  package: 'EDA-Application'
]]]

The ""registry"" should be accessed via dedicated methods, under the ''accessing'' protocol.

${changes:01-EDAApplications_registry_.ombu}$
${changes:02-EDAApplications_registry.ombu}$

[[[
EDAApplications
  compile: '
registry
  | result |
  result := registry.
  result ifNil: [ result := Dictionary new. self registry: result ].
  ^ result
'
  classified: 'accessing'
]]]

We'll throw a ==EDAApplicationAlreadyRegistered== exception in case the application is already registered.

[[[
Error subclass: #EDAApplicationAlreadyRegistered
  instanceVariableNames: ''
  classVariableNames: ''
  package: 'EDA-Application'
]]]

Now we can implement a method to register applications. We'll identify each application by its name.

[[[
EDAApplications
  compile: '
register: anEDAApplication under: anApplicationName
  self registry
    at: anApplicationName
    ifPresent: [ :app | EDAApplicationAlreadyRegistered signal: app printString ]
    ifAbsentPut: [ anEDAApplication ].
'
    classified: 'api'
]]]

To make the API simpler, let's add a new method in ==EDAApplications==:
[[[
EDAApplications
  compile: '
register: anEDAApplication
  self
    register: anEDAApplication
    under: anEDAApplication applicationName
'
    classified: 'api'
]]]

Now each application needs a name, but it could be optional at instance-level. We'd like to omit the instance name if only one instance will ever be created. In other words, an instance can have its own name, but can rely upon the class'.

We need to add the new attribute to ==EDAApplication==:

[[[
Object subclass: #EDAApplication
  uses: EDATLogging
  instanceVariableNames: 'applicationName eventStore eventAnnouncer commandConsumer commandDispatcher eventProducer commandListenerClientDebug isConfigured isStarted projectorsByTenant projectionSynchronizationEnabled'
  classVariableNames: 'ProjectionSynchronizationEnabled'
  package: 'EDA-Application'
]]]

The following accessors deal with that:

[[[
EDAApplication
  compile: '
applicationName
  ^ applicationName ifNil: [ self class applicationName ]
'
    classified: 'accessing'.
EDAApplication
  compile: '
applicationName: aString
  applicationName := applicationName
'
    classified: 'accessing'
]]]

We'll delegate on the class itself to provide a default name.

[[[
EDAApplication class
  compile: '
applicationName
  ^ ''default''
'
    classified: 'accessing'.
]]]

Now that every application instance has a name, and it's used to reference the application in the registry, we should provide a way to inspect the applications already registered:

[[[
EDAApplications
  compile: '
edaApplications
  ^ self registry values
'
    classified: 'api'
]]]

Recall that ==EDAApplication== was previously meant to be used as a class, not to create instances. It might be useful to guide developers on how to create new instances. If they use ""new"" and forget to provide a name, they'll end up with unnamed applications, and won't be able to register more than one in the registry. Therefore, we'll miss precisely the point we're trying to make.

This factory method (class-side) ensures the instances are created with a name. Notice we don't use ""new"". We're dealing with that soon enough.
[[[
EDAApplication class
  compile: '
withName: anApplicationName
  | result |
  result := self basicNew initialize.
  result applicationName: anApplicationName.
  ^ result
'
    classified: 'instance creation'
]]]

Analogously, we can create "unnamed" instances as well.

[[[
EDAApplication class
  compile: '
unnamed
  ^ self withName: self applicationName
'
    classified: 'instance creation'
]]]

However, instances can be created without a name (being "unnamed"). If we want to ensure instances are created via the factory methods above, we can override the ""new"" method.
[[[
EDAApplication class
  compile: '
new
  MessageNotUnderstood
    signal:
      ''Use '' , self class printString , ''>>withName: or ''
        , self class printString , ''>>unnamed instead''

'
    classified: 'instance creation'
]]]

We'd need to convert ==EDAApplications== into a singleton, to ensure there's only one registry of running applications. To do so, we add a ""uniqueInstance"" attribute on the class itself.
[[[
Object subclass: #EDAApplications
  uses: EDATLogging
  instanceVariableNames: 'registry'
  classVariableNames: 'uniqueInstance'
    package: 'EDA-Application'
]]]

Again, we use a lazy approach in the getter:

[[[
EDAApplications class
  compile: '
uniqueInstance
  | result |
  result := uniqueInstance.
  result
    ifNil: [ result := self new.
      self uniqueInstance: result ].
  ^ result
'
    classified: 'accessing'
]]]

  We use a trivial setter.

[[[
EDAApplications class
  compile: '
uniqueInstance: anInstance
  | result |
  uniqueInstance := anInstance
'
    classified: 'accessing'
]]]

Finally, we can create applications and register them.

[[[
EDAApplications uniqueInstance register: (EDAApplication withName: 'test-1')
]]]

And  inspect the registered applications as well.

[[[
EDAApplications uniqueInstance edaApplications
]]]


! Automatic registration of EDAApplications

At the expense of introducing a cyclic coupling between ==EDAApplication== and ==EDAApplications== classes, it's convenient to make sure all ==EDAApplication== instances get registered automatically.

[[[
EDAApplication
  compile: '
withName: anApplicationName
  | result |
  (EDAApplications uniqueInstance edaApplications
    select: [ :app | app applicationName = anApplicationName ])
    ifEmpty: [ result := self basicNew initialize.
      result applicationName: anApplicationName.
      EDAApplications uniqueInstance register: result ]
    ifNotEmpty: [ :c | result := c first ].
  ^ result
'
    classified: 'instance creation'
]]]

! Different subtrees for each application

In ==EDASettings== we need to build subtrees dynamically, based on the already registered applications.
We can create a new entry using the ""group:"" method of the ==SettingTreeBuilder== that is passed to the ==<systemsettings>==-tagged method: ==aBuilder group: #subtreeSymbol==

We need to ensure ==#subtreeSymbol== is unique. Otherwise the subtree will be created under an existing entry.

Let's remove the current ==<systemsettings>== pragma of ==EDASettings class>>edaSettingsOn:== and rename it to ==EDASettings class>>edaSettingsOn: aBuilder for: anEDAApplication under: aSymbol==, and let's write a new ==EDASettings class>>edaSettingsOn:== from scratch.

Since we haven't created (or registered) any application yet, we can choose either to skip creating anything, or display a message.
[[[
EDASettings class
  compile: '
edaSettingsOn: aBuilder
  <systemsettings>
  | root rootSymbol |
  rootSymbol := #edaApps.
  root := aBuilder group: rootSymbol.
  EDAApplications uniqueInstance edaApplications
    ifEmpty: [ root
        label: ''No PharoEDA applications'' translated;
        description: ''No PharoEDA applications registered'' ]
    ifNotEmpty: [ :apps |
      root
        label: ''PharoEDA application(s)'' translated , '': ''
               , apps size printString translated;
        description: ''Registered PharoEDA applications'';
        noOrdering.
        apps do: [ :app |
          self edaSettingsOn: aBuilder for: app under: rootSymbol ] ]
'
    classified: 'settings'
]]]

However, the old ""edaSettings:"" method uses a fixed symbol to place the application settings in the tree. Let's fix that. We'll start with the ==environmentSettingsOn:under:on:==. The rest of the methods will be fixed later.

[[[
EDASettings class
  compile: '
edaSettingsOn: aBuilder for: anEDAApplication under: aSymbol
  | parent parentGroup |
  parent := anEDAApplication applicationName.
  parentGroup := aBuilder group: parent.
  parentGroup
    label: parent translated;
    parent: aSymbol;
    description: parent;
    noOrdering.
  self
    environmentSettingsOn: aBuilder
    under: parent
    on: anEDAApplication.
    "
  self
    commandListenerSettingsOn: aBuilder
    under: parent.
  self
    eventPublisherSettingsOn: aBuilder
    under: parent.
  self
    eventStoreSettingsOn: aBuilder
    under: parent.
  self
    projectionSettingsOn: aBuilder
    under: parent
    populatedWithValuesFrom: ''projections''.
  self loggingSettingsOn: aBuilder under: parent.
  "
'
    classified: 'settings'
]]]

As you can see, we've renamed the previou method from ""environmentSettingsOn: aBuilder under: aSymbol"" to ""environmentSettingsOn: aBuilder: under: aSymbol on: anEDAApplication"". To display and manage each application's settings, we need the application instance. Previously, we used class-scoped attributes of predefined classes as settings. Now we're going to access them through the application instance itself.
We need to create a couple of files under ==config/== folder, with an initial json file in it called ""development.json"" and ""integration-tests.json"".
[[[
{}
]]]

  Additionally, we'll comment some settings code in ==EDATestSettings== class as well.
  [[[
  EDATestSettings class
  compile: '
  edaTestSettingsOn: aBuilder
	<systemsettings>
	(aBuilder group: #edatests)
		label: 'EDA Tests' translated;
		description: 'EDA tests';
		noOrdering;
		parent: #eda.
	"self commandPublisherSettingsOn: aBuilder.
	self eventListenerSettingsOn: aBuilder.
	self queueCleaningSettingsOn: aBuilder"
  '
  classified: 'settings'
]]]

! Ports and adapters

We might just add the settings as instance attributes of the ==EDAApplication== itself. Such solution would not be flexible enough.
To accomodate different implementations, we can abstract them as a Port. ==EDAApplication== instances will include a reference to a port, regardless of the actual implementation used.

The required ports are: environment, command listener, event publisher, event store, projections, and logging.

!! Minimal behavior shared among all  Settings Ports

Even though in Smalltalk there's no such thing as an interface (a definition of the contract exposed by all implementations), we'd like to ensure all adapters share certain behavior. For that, we'll use a trait.

[[[
Trait named: #EDATSettingsPort
  uses: {}
  package: 'EDA-Settings-Ports'
]]]

The most basic behavior all adapters should support is telling us a brief description of themselves.

[[[
EDATSettingsPort class
  compile: '
description
  self subclassResponsibility
'
    classified: 'settings'
]]]

! Environment setting

This setting is used to identify the environment. Currently, it shows the value of the ""PHARO_ENV"" environment variable. The first adapter would be one that supports this feature.

If we inspect the current logic used in ==EDASettings== to inject the environment setting into de ==SettingBrowser== tree, we see the following:

[[[
EDASettings class
  compile: '
environmentSettingsOn: aBuilder under: aParent on: app
  (aBuilder pickOne: #currentEnvironment)
    parent: aParent;
    target: EDADUEnvironment;
    label: ''Environment'' translated;
    description: ''Environment'';
    order: 1;
    domainValues:
      (EDADUEnvironment environments
        collect: [ :level | level translated -> level greaseString ]).
'
    classified: 'settings'
]]]

The nature of this setting is to choose one of the available environment. It's mainly informative, but it might impose certain restrictions or influence other settings as well.

!! Environment variable adapter

As its value is provided by the ""PHARO_ENV"" environment variable, it cannot be changed. We'll change the ""pickOne:"" above with a simple label, as we did before, when there're no registered applications.

[[[
Object subclass: #EDAEnvironmentSettingsEnvVarAdapter
  uses: EDATSettingsPort
  instanceVariableNames: ''
  classVariableNames: ''
  package: 'EDA-Settings-Adapters-EnvVars'
]]]

Now we need to distinguish between the case in which the value is a single string, and the previous assumption that it'd always be a list of items. A simple way to accomplish it is to ask the port itself. Remember that ==EDASettings== relies on ==EDAApplication== to provide the settings, and the latter only deals with ports, not adapters. It makes sense to create a new custom ==EDATSettingsPort== specifically for the environment-related adapters.

[[[
Trait named: #EDATEnvironmentSettingsPort
  uses: EDATSettingsPort
  package: 'EDA-Settings-Ports'
]]]

Of course, we'll use that trait in our current adapter instead of the generic one we were using.

[[[
Object subclass: #EDAEnvironmentSettingsEnvVarAdapter
  uses: EDATEnvironmentSettingsPort
  instanceVariableNames: ''
  classVariableNames: ''
  package: 'EDA-Settings-Adapters-EnvVars'
]]]

This variation can now be accomodated in the new ==EDATEnvironmentSettingsPort==.

[[[
EDATEnvironmentSettingsPort
      compile: '
supportsMultiple
  self subclassResponsibility
'
    classified: 'testing'
]]]

Now, ==EDASettings== can include both variations:
[[[
EDASettings class
      compile: '
environmentSettingsOn: aBuilder under: aParent on: app
  | entry port |
  port := app environmentSettingsPort.
  (port supportsMultiple)
    ifTrue: [ entry := aBuilder pickOne: #currentEnvironment.
      entry
        domainValues:
          (EDADUEnvironment environments
            collect: [ :level | level translated -> level greaseString ]) ]
    ifFalse: [ entry := aBuilder setting: #currentEnvironment ].
  entry
    parent: aParent;
    target: port;
    label: ''Environment'' translated;
    description: ''The current environment'' translated;
    order: 1
'
      classified: 'settings'
]]]

==EDAApplication== has to provide an adapter for its ""environmentSettingsPort"" somehow. We'll deal with a mechanism to choose from a list of available adapters soon. For now, let's return the one we've just implemented: ==EDAEnvironmentSettingsEnvVarAdapter==.

[[[
Object subclass: #EDAApplication
  uses: EDATLogging
  instanceVariableNames: 'applicationName commandConsumer commandDispatcher commandListenerClientDebug environmentSettingsPort eventAnnouncer  eventProducer eventStore isConfigured isStarted projectorsByTenant projectionSynchronizationEnabled'
  classVariableNames: 'ProjectionSynchronizationEnabled'
  package: 'EDA-Application'.

EDAApplication
      compile: '
environmentSettingsPort
  | result |
  result := environmentSettingsPort.
  result ifNil: [
    result := EDAEnvironmentSettingsEnvVarAdapter new.
    self environmentSettingsPort: result
  ].
  ^ result
'
      classified: 'accessing'.

EDAApplication
  compile: '
environmentSettingsPort: anAdapter
  anAdapter = environmentSettingsPort
  ifTrue: [ ^ self ].
  environmentSettingsPort := anAdapter
'
    classified: 'accessing'
]]]

When we launch a ==SettingBrowser== we get an ==SubclassResponsibility== error. Let's implement it in our adapter. But does it support a list of values? Actually, no. We cannot change the value of the environment value.

[[[
EDAEnvironmentSettingsEnvVarAdapter
      compile: '
supportsMultiple
  ^ false
'
      classified: 'testing'
]]]

Running again ==SettingBrowser== will try to call ""currentEnvironment"" on our adapter, but we haven't implemented  it yet. Let's do it now.

[[[
EDAEnvironmentSettingsEnvVarAdapter
      compile: '
currentEnvironment
  ^ OSPlatform current environment at: ''PHARO_ENV'' ifAbsent: ''(PHARO_ENV not set)''
'
      classified: 'environment-variables'
]]]

==SettingBrowser== should render the tree now, but we're not done yet with this adapter. ==EDASettings== assumes the setting can be customized. That is, the adapter supports setting a new value. How can we make it read-only? First of all, ==EDASettings== mustn't make any assumption. It's responsibility of the port to provide that information. Based on that, ==EDASettings== will choose how to properly display the entry it the tree.

[[[
EDASettings class
      compile: '
environmentSettingsOn: aBuilder under: aParent on: app
  | entry port |
  port := app environmentSettingsPort.
  (port supportsMultiple)
    ifTrue: [ entry := aBuilder pickOne: #currentEnvironment.
      entry
        domainValues:
          (EDADUEnvironment environments
            collect: [ :level | level translated -> level greaseString ]) ]
    ifFalse: [ (port isReadOnly)
      ifTrue: [ entry := aBuilder group: #currentEnvironment.
        entry dialog: [ LabelMorph newLabel: port currentEnvironment ] ]
      ifFalse: [ entry := aBuilder setting: #currentEnvironment ]
    ].
  entry
    parent: aParent;
    target: aConfig;
    label: aString translated;
    description: aDescription;
    order: 1
'
      classified: 'settings'
]]]

So if the port's ""isReadOnly"" returns ""true"", then ==EDASettings== will use a ==LabelMorph== to display the value provided by the port itself.

We're implementing the ports as traits. It makes sense to indicate all adapters need to override this method.
[[[
EDATEnvironmentSettingsPort
      compile: '
isReadOnly
  self subclassResponsibility
'
      classified: 'testing'
]]]

Our adapter clearly needs to return ""true"":
[[[
EDATEnvironmentSettingsEnvVarAdapter
      compile: '
isReadOnly
  ^ true
'
      classified: 'testing'
]]]

!!! Refactoring

Even though our adapter is working, it's not reusable. Every other setting whose value comes from an environment variable would need to share most of its behavior. Before continuing with the next adapter, let's refactor this a bit.

First, let's extract the logic to retrieve values from environment variables into its own trait.

[[[
Trait named: #EDATEnvVarAdapter
  uses: EDATSettingsPort
  package: 'EDA-Settings-Adapters-EnvVars'
]]]

[[[
    EDATEnvVarAdapter
      compile: '
    getValueFor: envVarName orElse: defaultValue
^ OSPlatform current environment
    at: envVarName
    ifAbsent: defaultValue
'
      classified: 'environment-settings'
]]]

[[[
    EDATEnvVarAdapter
      compile: '
  supportsMultiple
    ^ false
'
    classified: 'testing'

]]]

[[[
    EDATEnvVarAdapter
      compile: '
  isReadOnly
    ^ true
'
      classified: 'testing'
]]]

Our adapter now uses this new trait instead of ==EDATSettingsPort==:
[[[
Object subclass: #EDAEnvironmentSettingsEnvVarAdapter
  uses: EDATEnvVarAdapter
  instanceVariableNames: ''
  lassVariableNames: ''
  package: 'EDA-Settings-Adapters-EnvVars'
]]]

Finally, the ""currentEnvironment"" implementation delegates the logic to the new trait:

[[[
    EDAEnvironmentSettingsEnvVarAdapter
      compile: '
    currentEnvironment
^ self
    getValueFor: 'PHARO_ENV'
    orElse: '(PHARO_ENV not set)'
'
      classified: 'environment'
]]]

!! Predefined list adapter

This adapter allows the user to choose among a predefined list of possible values for the environment setting.
From the point of view of ==EDASettings==, if the port supports multiple values, it needs to provide them in advance.

[[[
EDASettings class
      compile: '
environmentSettingsOn: aBuilder under: aParent on: app
  | entry port |
  port := app environmentSettingsPort.
  (port supportsMultiple)
    ifTrue: [ entry := aBuilder pickOne: #currentEnvironment.
      entry
        domainValues:
          (port availableEnvironments
            collect: [ :level | level translated -> level greaseString ]) ]
    ifFalse: [ (port isReadOnly)
      ifTrue: [ entry := aBuilder group: #currentEnvironment.
        entry dialog: [ LabelMorph newLabel: port currentEnvironment ] ]
      ifFalse: [ entry := aBuilder setting: #currentEnvironment ]
    ].
  entry
    parent: aParent;
    target: aConfig;
    label: aString translated;
    description: aDescription;
    order: 1
'
    classified: 'settings'
]]]

For the new adapter, let's create a new package ==EDA-Settings-Adapters-InMemory== first.

[[[
Object subclass: #EDAPredefinedEnvironmentSettingsInMemoryAdapter
  uses: EDATEnvironmentSettingsPort
  instanceVariableNames: 'currentEnvironment'
  classVariableNames: ''
  package: 'EDA-Settings-Adapters-InMemory'
]]]

 It needs to store the selected value in memory.

[[[
EDAPredefinedEnvironmentSettingsInMemoryAdapter
      compile: '
currentEnvironment
  ^ currentEnvironment ifNil: [ self availableEnvironments first ]
'
      classified: 'accessing'
]]]

[[[
EDAPredefinedEnvironmentSettingsInMemoryAdapter
      compile: '
currentEnvironment: aByteString
  currentEnvironment := aByteString
'
    classified: 'accessing'
]]]

The list of predefined values is provided by the ""availableEnvironments"" method, used also by ==EDASettings==:

[[[
EDAPredefinedEnvironmentSettingsInMemoryAdapter
      compile: '
availableEnvironments
  ^ OrderedCollection with: 'dev' with: 'test' with: 'PRO'
'
      classified: 'accessing'
]]]

We need to tell that the new adapter supports multiple values, so ==EDASettings== uses ""pickOne:"" to render the setting.

[[[
EDAPredefinedEnvironmentSettingsInMemoryAdapter
      compile: '
    supportsMultiple
  ^ true
'
      classified: 'testing'
]]]

Also, even though now it's not strictly necessary, this adapter supports read-write values, in case anyone needs to know it.

[[[
EDAPredefinedEnvironmentSettingsInMemoryAdapter
      compile: '
    isReadOnly
  ^ false
'
      classified: 'testing'
]]]

Finally, to test it we can just change ==EDAApplication== to use it instead of the current one. We'll introduce a mechanism to inject adapters into ports dynamically soon.

[[[
EDAApplication
      compile: '
environmentSettingsPort
  | result |
  result := environmentSettingsPort.
  result ifNil: [
    result := EDAPredefinedEnvironmentSettingsInMemoryAdapter new.
    self environmentSettingsPort: result
  ].
  ^ result
'
    classified: 'accessing'
]]]

!!! Refactoring

As we did with the environment-variable adapter, let's introduce a new intermediary trait, common to all "in-memory" adapters, to indicate ""isReadOnly"" is by default ""false"".

[[[
Trait named: #EDATInMemoryAdapter
  uses: EDATSettingsPort
  package: 'EDA-Settings-Adapters-InMemory'
]]]

[[[
Object subclass: #EDAPredefinedEnvironmentSettingsInMemoryAdapter
  uses: EDATInMemoryAdapter
  instanceVariableNames: 'currentEnvironment'
  classVariableNames: ''
  package: 'EDA-Settings-Adapters-InMemory'
]]]
