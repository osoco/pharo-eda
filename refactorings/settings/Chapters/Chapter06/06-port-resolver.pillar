!! Port resolver

!!! Discovering adapters

We have implemented two adapters so far. One that takes the ""environment"" information from an environment variable, and another one that lets the user choose among a predefined list of values. Which one is used gets determined by ==EDAApplication== accessor for ""environmentSettingsPort"". How can we decide which adapter should be used? We need a piece to handle that for us.

From ==EDAApplication== point of view, given a port, we can find the classes using it. We assume the port is a trait and the classes using it are the adapters the user can choose from. However, we can soften the last assumption by asking the adapter if it accepts the port semantics.

Let's create a new trait ==EDATPortResolver==.

% ${changes:path=code/001-EDATPortResolver.ombu}$
[[[classDefinition=true
Trait named: #EDATPortResolver
	uses: {}
	package: 'EDA-Settings-Ports'
]]]

% ${changes:path=code/002-EDATPortResolver_availableAdapters_.ombu}$
[[[methodDefinition=true|lineNumber=true
EDATPortResolver >> availableAdapters: aPort
  ^ aPort traitUsers select: [ :cls | cls accepts: self ]
]]]

By default, ==EDATEnvironmentSettingsPort== should reject itself as adapter for any port. It's useful when we have unfinished adapters and we don't want them to interfere with ==SettingBrowser==.

% ${changes:path=code/003-EDATEnvironmentSettingsPort_classTrait_accepts_.ombu}$
[[[methodDefinition=true|lineNumber=true
EDATEnvironmentSettingsPort classTrait >>accepts: aPort
  ^ false
]]]

Our existing adapters can override that method, so they can be discovered by ==EDATByPriorityAdapter==.

% ${changes:path=code/004-EDAEnvironmentSettingsEnvVarAdapter_class_accepts_.ombu}$
[[[methodDefinition=true|lineNumber=true
EDAEnvironmentSettingsEnvVarAdapter class >> accepts: aPort
  ^ true
]]]

% ${changes:path=code/005-EDAPredefinedEnvironmentSettingsInMemoryAdapter_class_accepts_.ombu}$
[[[methodDefinition=true|lineNumber=true
EDAPredefinedEnvironmentSettingsInMemoryAdapter class >> accepts: aPort
  ^ true
]]]

We can move on, and implement the way ports get resolved. First, let's create a new class ==EDAPortResolver==.

% ${changes:path=code/006-EDAPortResolver.ombu}$
[[[classDefinition=true
Object subclass: #EDAPortResolver
	uses: EDATPortResolver
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'EDA-Settings-Ports'
]]]

Second, make it be able to provide all available adapters for a given port:

% ${changes:path=code/007-EDAPortResolver_resolveSettingsPort_.ombu}$
[[[methodDefinition=true|lineNumber=true
EDAPortResolver >> resolveSettingsPort: aPort
  | candidates candidate |
  candidates := (self availableAdapters: aPort) sorted.
  candidate :=
    candidates
      ifEmpty: [ nil ]
      ifNotEmpty: [ :col | col first ].
  ^ candidate ifNil: [ nil ] ifNotNil: [ :c | c new ]
]]]

Third, make ==EDAApplication== use it.

% ${changes:path=code/008-EDAApplication_environmentSettingsPort.ombu}$
[[[methodDefinition=true|lineNumber=true
EDAApplication >> environmentSettingsPort
  | result |
  result := environmentSettingsPort.
  result
    ifNil: [
      result := EDAPortResolver new resolveSettingsPort: EDATEnvironmentSettingsPort.
      self environmentSettingsPort: result ].
  ^ result
]]]

If we try to open ==SettingBrowser==, it might fail because the ==EDAApplications== registry refers to ==EDAApplication== instances with old code. If that's the case, you can empty the registry and register a new instance.

[[[
EDAApplications uniqueInstance registry: Dictionary new.
EDAApplication withName: 'test-2'.
]]]

Our naive implementation sorts the adapters it finds, sorts them, and picks the first one. But we can now use it to resolve any other port, not only the ""environment""'s, by finding all available adapters and sorting them.

!!! A port to choose adapters

Our purpose now is to avoid the limitation of not being able to select anything but the first adapter. Let's add a new entry in ==SettingBrowser== to let us choose among the available adapters. What we are doing for ""environment"" will be the basis for the rest of the configuration entries.

We need a new ""portSettingsPort"" attribute in ==EDAApplication==:

% ${changes:path=code/009-EDAApplication.ombu}$
[[[classDefinition=true
Object subclass: #EDAApplication
	uses: EDATLogging
	instanceVariableNames: 'applicationName commandConsumer commandDispatcher commandListenerClientDebug environmentSettingsPort eventAnnouncer eventProducer eventStore isConfigured isStarted projectorsByTenant projectionSynchronizationEnabled portSettingsPort'
	classVariableNames: 'ProjectionSynchronizationEnabled'
	package: 'EDA-Application'
]]]

Do not forget to generate the accessors as well.

% ${changes:path=code/010-EDAApplication_portSettingsPort.ombu}$
[[[methodDefinition=true|lineNumber=true
EDAApplication >> portSettingsPort
  ^ portSettingsPort
]]]

% ${changes:path=code/011-EDAApplication_portSettingsPort_.ombu}$
[[[methodDefinition=true|lineNumber=true
EDAApplication >> portSettingsPort: anObject
  portSettingsPort := anObject
]]]

The purpose of this port is to let the user choose the adapter (for the other ports) from a list of available options.

Let's define the port itself:

% ${changes:path=code/012-EDATPortSettingsPort.ombu}$
[[[classDefinition=true
Trait named: #EDATPortSettingsPort
	 uses: EDATSettingsPort
	 package: 'EDA-Settings-Ports'
]]]

This new port also needs to provide ""isReadOnly"" and ""supportsMultiple"" information, required when building the settings tree for ==SettingBrowser==. Let's move them from ==EDATEnvironmentSettingsPort== to ==EDATSettingsPort==, so they are defined for any port from now on.

% ${changes:path=code/013-EDATSettingsPort_isReadOnly.ombu}$
[[[methodDefinition=true|lineNumber=true
EDATSettingsPort >> isReadOnly
  self shouldBeImplemented
]]]

% ${changes:path=code/014-EDATSettingsPort_supportsMultiple.ombu}$
[[[methodDefinition=true|lineNumber=true
EDATSettingsPort >> supportsMultiple
  self shouldBeImplemented
]]]

The adapter of this new port will store the selected adapter in memory, but since there'll be no other adapters, so for the sake of clarity we'll call it ==EDAPortSettingsPort==:

% ${changes:path=code/015-EDAPortSettingsPort.ombu}$
[[[classDefinition=true
Object subclass: #EDAPortSettingsPort
	uses: EDATPortSettingsPort + EDAPrintOnHelper
	instanceVariableNames: 'environmentSettingsResolverPortClass'
	classVariableNames: ''
	package: 'EDA-Settings-Ports'
]]]

Initially, we'll use it to choose the adapter in charge of the ""environment"" setting. That's why we added it the ""environmentSettingsResolverPortClass"" attribute.

We need its accessors as well. The setter is straightforward.

% ${changes:path=code/016-EDAPortSettingsPort_environmentSettingsResolverPortClass_.ombu}$
[[[methodDefinition=true|lineNumber=true
EDAPortResolverInMemoryAdapter >> environmentSettingsResolverPortClass: anAdapterClass
  environmentSettingsResolverPortClass := anAdapterClass
]]]

For the getter, we'll initialize it with ==EDAEnvironmentSettingsInMemoryAdapter==.

% ${changes:path=code/017-EDAPortSettingsPort_environmentSettingsResolverPortClass.ombu}$
[[[methodDefinition=true|lineNumber=true
EDAPortResolverInMemoryAdapter >> environmentSettingsResolverPortClass
  environmentSettingsResolverPortClass
    ifNil: [ self environmentSettingsResolverPortClass: EDAEnvironmentSettingsInMemoryAdapter ].
  ^ environmentSettingsResolverPortClass
]]]

Now we can fix the ==EDAApplication== ""portSettingsPort"" getter to create a new ==EDAPortSettingsPort== the first time.

% ${changes:path=code/018-EDAApplication_portSettingsPort.ombu}$
[[[methodDefinition=true|lineNumber=true
EDAApplication >> portSettingsPort
  ^ portSettingsPort
      ifNil: [ | result |
        result := EDAPortSettingsPort new.
        self portSettingsPort: result.
        result ]
]]]

We are close to be able to manage which adapter to use for our ""environment"" setting. This new method in ==EDASettings== will create the subtree for us.

% ${changes:path=code/019-EDASettings_class_portSettingsOn_under_on_.ombu}$
[[[methodDefinition=true|lineNumber=true
EDASettings class >> portSettingsOn: aBuilder under: aParent on: app
  | entry values key portResolver |
  key := aParent , 'ports'.
  entry := aBuilder group: key.
  entry
    label: 'Ports' translated;
    parent: aParent.
    portResolver := EDAPortResolver new.
    values :=
      OrderedCollection
        withAll:
          ((portResolver availableAdapters: EDATEnvironmentSettingsPort)
            collect: [ :adapterClass | adapterClass description translated -> adapterClass ]).
  (aBuilder pickOne: #environmentSettingsResolverPortClass)
    label: 'Environment adapter' translated;
    target: app portSettingsPort;
    parent: key;
    domainValues: values
]]]

We need only to call it as part of ""edaSettingsOn:for:under:"".

% ${changes:path=code/020-EDASettings_class_edaSettingsOn_for_under_.ombu}$
[[[methodDefinition=true|lineNumber=true
EDASettings class >> edaSettingsOn: aBuilder for: anEDAApplication under: aSymbol
  | parent parentGroup |
  parent := anEDAApplication applicationName.
  parentGroup := aBuilder group: parent.
  parentGroup
    label: parent translated;
    parent: aSymbol;
    description: parent;
    noOrdering.
  self
    environmentSettingsOn: aBuilder
    under: parent
    on: anEDAApplication.
  self portSettingsOn: aBuilder under: parent on: anEDAApplication
]]]

If we open ==SettingBrowser== now, we can see the new subtree. However, it's not working as we expected. It doesn't seem to display the list of available adapters. Additionally, the only entry is not useful to distinguish the actual adapter.

Let's inspect the adapters ==EDAPortResolver== is able to detect:
[[[eval=true
EDAPortResolver new availableEnvironmentSettingsAdapters
]]]

We see it finds only the ==EDAEnvironmentSettingsEnvVarAdapter==. Let's fix its ""description"" first.

% ${changes:path=code/021-EDAEnvironmentSettingsEnvVarAdapter_class_description.ombu}$
[[[methodDefinition=true
EDAEnvironmentSettingsEnvVarAdapter class >> description
	^ 'Environment variable'
]]]

What is missing in order to enable ==EDAEnvironmentSettingsInMemoryAdapter== is overriding the ""accepts:"" method.

% ${changes:path=code/022-EDAEnvironmentSettingsInMemoryAdapter_class_accepts_.ombu}$
[[[methodDefinition=true
EDAEnvironmentSettingsInMemoryAdapter class >> accepts: aPort
	^ true
]]]

Additionally, ==EDAPredefinedEnvironmentSettingsInMemoryAdapter== didn't use the ==EDATEnvironmentSettingsPort== trait:

% ${changes:path=code/023-EDAPredefinedEnvironmentSettingsInMemoryAdapter.ombu}$
{{{classDefinition=true
Object subclass: #EDAPredefinedEnvironmentSettingsInMemoryAdapter
	uses: EDATInMemoryAdapter + EDATEnvironmentSettingsPort
	instanceVariableNames: 'currentEnvironment'
	classVariableNames: ''
	package: 'EDA-Settings-Adapters-InMemory'
}}}
