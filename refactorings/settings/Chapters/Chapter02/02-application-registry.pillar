!! Application registry

We need a way to know which ==EDAApplication== instances exist, and a way to interact with them. A simple registry is enough for now.

Let's start by creating the class with a ""registry"" attribute we'll use to annotate the references to the existing applications.

[[[classDefinition=true
Object subclass: #EDAApplications
  uses: EDATLogging
  instanceVariableNames: 'registry'
  classVariableNames: ''
  package: 'EDA-Application'
]]]

The ""registry"" should be accessed via dedicated methods, under the ''accessing'' protocol.

[[[methodDefinition=true|lineNumber=true
EDAApplications >> registry: aDictionary
  registry := aDictionary
]]]
% ${changes:path=code/001-EDAApplications_registry_.ombu}$

[[[methodDefinition=true|lineNumber=true
EDAApplications >> registry
  | result |
  result := registry.
  result ifNil: [
    result := Dictionary new.
    self registry: result
  ].
  ^ result
]]]
% ${changes:path=code/002-EDAApplications_registry.ombu}$

We'll throw an ==EDAApplicationAlreadyRegistered== exception in case the application is already registered.

[[[
Error subclass: #EDAApplicationAlreadyRegistered
  instanceVariableNames: ''
  classVariableNames: ''
  package: 'EDA-Application'
]]]

Now we can implement a method to register applications. We'll identify each application by its name.

[[[methodDefinition=true|lineNumber=true
EDAApplications >> register: anEDAApplication under: anApplicationName
  self registry
    at: anApplicationName
    ifPresent: [ :app | EDAApplicationAlreadyRegistered signal: app printString ]
    ifAbsentPut: [ anEDAApplication ]
]]]
% ${changes:path=code/003-EDAApplications_register_under_.ombu}$

[[[methodDefinition=true|lineNumber=true
EDAApplications >> register: anEDAApplication
  self
    register: anEDAApplication
    under: anEDAApplication applicationName
]]]
% ${changes:path=code/004-EDAApplications_register_.ombu}$

Now each application needs a name, but it could be optional at instance level. We'd like to omit the instance name if only one instance will ever be created. In other words, an instance can have its own name, but can rely upon the class'.

We need to add the new attribute to ==EDAApplication==:

[[[classDefinition=true
Object subclass: #EDAApplication
  uses: EDATLogging
  instanceVariableNames: 'applicationName eventStore eventAnnouncer commandConsumer commandDispatcher eventProducer commandListenerClientDebug isConfigured isStarted projectorsByTenant projectionSynchronizationEnabled'
  classVariableNames: ''
  package: 'EDA-Application'
]]]

The following accessors deal with that:

[[[methodDefinition=true|lineNumber=true
EDAApplication >> applicationName
  ^ applicationName ifNil: [ self class applicationName ]
]]]

% ${changes:path=code/005-EDAApplication_applicationName.ombu}$
[[[methodDefinition=true|lineNumber=true
EDAApplication >> applicationName: aString
  applicationName := applicationName
]]]
% ${changes:path=code/006-EDAApplication_applicationName_.ombu}$

We'll delegate on the class itself to provide a default name.

[[[methodDefinition=true|lineNumber=true
EDAApplication class >> applicationName
  ^ 'default'
]]]
% ${changes:path=code/007-EDAApplication_class_applicationName.ombu}$

Now that every application instance has a name, and it's used to reference the application in the registry, we should provide a way to inspect the applications already registered:

%${changes:path=code/008-EDAApplications_edaApplications.ombu}$
[[[methodDefinition=true|lineNumber=true
EDAApplications >> edaApplications
  ^ self registry values
]]]

Recall that ==EDAApplication== was previously meant to be used as a class, not to create instances. It might be useful to guide developers on how to create new instances. If they use ""new"" and forget to provide a name, they'll end up with unnamed applications, and won't be able to register more than one in the registry. Therefore, we'll miss precisely the point we're trying to make.

This (class-side) factory method ensures the instances are created with a name. Notice we don't use ""self new"". We're dealing with that soon enough.

[[[methodDefinition=true|lineNumber=true
EDAApplication class >> withName: anApplicationName
  | result |
  result := super new.\n
  result applicationName: anApplicationName.
  ^ result
]]]
% ${changes:path=code/009-EDAApplication_class_withName.ombu}$

Analogously, we can create "unnamed" instances as well.

[[[methodDefinition=true|lineNumber=true
EDAApplication class >> unnamed
  ^ self withName: self applicationName
]]]
% ${changes:path=code/010-EDAApplication_class_unnamed.ombu}$

However, instances can be created without a name (being "unnamed"). If we want to ensure instances are created via the factory methods above, we can override the ""new"" method.

[[[methodDefinition=true|lineNumber=true
EDAApplication class >> new
  MessageNotUnderstood
    signal:
      'Use ' , self class printString , ' >> withName: or ' , self class printString , ' >> unnamed instead'
]]]
% ${changes:path=code/011-EDAApplication_class_new.ombu}$

We'd need to convert ==EDAApplications== into a singleton, to ensure there's only one registry of running applications. To do so, we add a ""uniqueInstance"" attribute on the class itself.
[[[classDefinition=true
EDAApplications class
  uses: EDATLogging classTrait
  instanceVariableNames: 'uniqueInstance'
]]]

Again, we use a lazy approach in the getter:

[[[methodDefinition=true|lineNumber=true
EDAApplications class >> uniqueInstance
  | result |
  result := uniqueInstance.
  result
    ifNil: [
      result := self new.
      self uniqueInstance: result
    ].
  ^ result
]]]
% ${changes:path=code/012-EDAApplications_class_uniqueInstance.ombu}$

For the sake of completeness, we define the trivial setter.

[[[methodDefinition=true|lineNumber=true
EDAApplications class >> uniqueInstance: anInstance
  uniqueInstance := anInstance
]]]
% ${changes:path=code/013-EDAApplications_class_uniqueInstance_.ombu}$

!!! Registration of EDAApplications

At the expense of introducing a cyclic coupling between ==EDAApplication== and ==EDAApplications== classes, it's convenient to make sure all ==EDAApplication== instances get registered automatically.

[[[methodDefinition=true|lineNumber=true
EDAApplication class >> withName: anApplicationName
  | result |
  (EDAApplications uniqueInstance edaApplications
    select: [ :app | app applicationName = anApplicationName ])
    ifEmpty: [
      result := super new.
      result applicationName: anApplicationName.
      EDAApplications uniqueInstance register: result ]
    ifNotEmpty: [ :c | result := c first ].
  ^ result
]]]
% ${changes:path=code/014-EDAApplication_class_withName_.ombu}$

Finally, we can create applications and get them automatically registered.

[[[
EDAApplication withName: 'test-1'
]]]
