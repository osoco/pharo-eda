#+TITLE: Settings per application in PharoEDA
#+AUTHOR: Jose San Leandro Armend√°riz
#+EMAIL: github@acm-sl.org
#+LANGUAGE: en
#+OPTIONS: <:nil
#+OPTIONS: toc:t
#+OPTIONS: date:nil
#+LATEX_CLASS: article
#+LATEX_HEADER: \usepackage[x11names]{xcolor}
#+LATEX_HEADER: \hypersetup{linktoc = all, colorlinks = true, urlcolor = DodgerBlue4, citecolor = PaleGreen1, linkcolor = black}
#+LATEX_HEADER: \usepackage{parskip}
#+EXPORT_FILE_NAME: settings-per-application-in-PharoEDA.pdf

* Introduction

Currently, only one PharoEDA application can be running in a Pharo image.

A =EDAApplication= has configurable properties, that can be inspected and modified using =SettingBrowser=.
The =SettingBrowser= customization is done in =EDASettings= class, using the =<systemsettings>= pragma, which requires the method to be on the class side.
Since that method expects a class and accessors to inspect and modify each setting, a simple approach might just consist of using specific classes, not instances, directly. The main benefit of this approach is to make =EDASettings= unaware of the existence of the =EDAApplication= class. However, this only applies on the surface, because both classes know which classes contain the setting values.

Additionally, the configuration settings are read from a json file, which gets identified by an environment variable. But that file is only used for the initial values, and its contents are not synchronized with the values of the application after they are modified using =SettingBrowser=. Ideally, each setting could be managed differently: either from an environment variable, from a json file, or manually.

* Motivation

On one hand, to avoid using classes as setting containers, and sharing them between =EDASettings= and =EDAApplication=.
On the other hand, to be able to manage more than one =EDAApplication= instance. Every instance should have its own settings, and its own subtree in =SettingBrowser=.
Finally, abstract the holder of each setting so the actual value can be obtained from different sources.

* Application registry

We need a way to know which =EDAApplication= instances exist, and a way to interact with them. A simple registry is enough for now.

Let's start by creating the class, with a *registry* attribute we'll use to annotate the references to the existing applications.

#+begin_src smalltalk
Object subclass: #EDAApplications
  uses: EDATLogging
  instanceVariableNames: 'registry'
  classVariableNames: ''
  package: 'EDA-Application'
#+end_src

The *registry* should be accessed via dedicated methods, under the /accessing/ protocol.

#+begin_src smalltalk
EDAApplications>>registry: aDictionary
  registry := aDictionary
#+end_src

#+begin_src smalltalk
EDAApplications>>registry
  | result |
  result := registry.
  result ifNil: [ result := Dictionary new. self registry: result ].
  ^ result
#+end_src

Now we can implement a method to register applications. We'll identify each application by its name.

#+begin_src smalltalk
EDAApplications>>register: anEDAApplication under: anApplicationName
  self registry
    at: anApplicationName
    ifPresent: [ :app | EDAApplicationAlreadyRegistered signal: app printString ]
    ifAbsentPut: [ anEDAApplication ].
#+end_src

We throw a =EDAApplicationAlreadyRegistered= exception in case the application is already registered.

#+begin_src smalltalk
Error subclass: #EDAApplicationAlreadyRegistered
  instanceVariableNames: ''
  classVariableNames: ''
  package: 'EDA-Application'
#+end_src

To make the API simpler, let's add a new method in =EDAApplications=:
#+begin_src smalltalk
EDAApplications>>register: anEDAApplication
  self
    register: anEDAApplication
    under: anEDAApplication applicationName
#+end_src

Now each application needs a name, but it could be optional at instance-level. We'd like to omit the instance name if only one instance will ever be created. In other words, an instance can have its own name, but can rely upon the class'.

We need to add the new attribute to =EDAApplication=:

#+begin_src smalltalk
Object subclass: #EDAApplication
  uses: EDATLogging
  instanceVariableNames:  'applicationName ...'
  package: 'EDA-Application'
#+end_src

The following getter accessor deals with that (the setter is omitted for brevity):

#+begin_src smalltalk
EDAApplication>>applicationName
  ^ applicationName ifNil: [ self class applicationName ]
#+end_src

Now that every application instance has a name, and it's used to reference the application in the registry, we should provide a way to inspect the applications already registered:

#+begin_src smalltalk
EDAApplications>>edaApplications
  ^ self registry values
#+end_src

Recall that =EDAApplication= was previously meant to be used as a class, not to create instances. It might be useful to guide developers on how to create new instances. If they use *new* and forget to provide a name, they'll end up with unnamed applications, and won't be able to register more than one in the registry. Therefore, we'll miss precisely the point we're trying to make.

This factory method (class-side) ensures the instances are created with a name. Notice we don't use *new*. We're dealing with that soon enough.
#+begin_src smalltalk
EDAApplication class>>withName: anApplicationName
  | result |
  result := self basicNew initialize.
  result applicationName: anApplicationName.
  ^ result
#+end_src

Analogously, we can create "unnamed" instances as well.

#+begin_src smalltalk
EDAApplication class>>unnamed
  ^ self withName: self applicationName
#+end_src

However, instances can be created without a name (being "unnamed"). If we want to ensure instances are created via the factory methods above, we can override the *new* method.
#+begin_src smalltalk
EDAApplication class>>new
  MessageNotUnderstood
    signal:
      'Use ' , self class printString , '>>withName: or '
        , self class printString , '>>unnamed instead'
#+end_src

We'd need to convert =EDAApplications= into a singleton, to ensure there's only one registry of running applications. To do so, we add a *uniqueInstance* attribute on the class itself.
#+begin_src smalltalk
EDAApplications class
  uses: EDATLogging classTrait
  instanceVariableNames: 'uniqueInstance'
#+end_src

Again, we use a lazy approach in the getter, and omit the trivial setter:

#+begin_src smalltalk
EDAApplication class>>uniqueInstance
  | result |
  result := uniqueInstance.
  result
    ifNil: [ result := self new.
      self uniqueInstance: result ].
  ^ result
#+end_src

Finally, we can create applications and register them.

#+begin_src smalltalk
EDAApplications uniqueInstance register: (EDAApplication withName: 'test-1')
#+end_src

And  inspect the registered applications as well.

#+begin_src smalltalk
EDAApplications uniqueInstance edaApplications
#+end_src


* Automatic registration of EDAApplications

At the expense of introducing a cyclic coupling between =EDAApplication= and =EDAApplications= classes, it's convenient to make sure all =EDAApplication= instances get registered automatically.

#+begin_src smalltalk
EDAApplication>>withName: anApplicationName
  | result |
  (EDAApplications uniqueInstance edaApplications
    select: [ :app | app applicationName = anApplicationName ])
    ifEmpty: [ result := self basicNew initialize.
      result applicationName: anApplicationName.
      EDAApplications uniqueInstance register: result ]
    ifNotEmpty: [ :c | result := c first ].
  ^ result
#+end_src

* Different subtrees for each application

In =EDASettings= we need to build subtrees dynamically, based on the already registered applications.
We can create a new entry using the *group:* method of the =SettingTreeBuilder= that is passed to the /<systemsettings>/-tagged method.
#+begin_src smalltalk
aBuilder group: #subtreeSymbol
#+end_src
We need to ensure /#subtreeSymbol/ is unique. Otherwise the subtree will be created under an existing entry.

Let's remove the current /<systemsettings>/ pragma of *EDASettings class>>edaSettingsOn:* and rename it to *EDASettings class>>edaSettingsOn: aBuilder for: anEDAApplication under: aSymbol*, and let's write a new *EDASettings class>>edaSettingsOn:* from scratch.

Since we haven't created (or registered) any application yet, we can choose either to skip creating anything, or display a message.
#+begin_src
EDASettings class
  compile: '
edaSettingsOn: aBuilder
  <systemsettings>
  | root rootSymbol |
  rootSymbol := #edaApps.
  root := aBuilder group: rootSymbol.
  EDAApplications uniqueInstance edaApplications
    ifEmpty: [ root
        label: ''No PharoEDA applications'' translated;
        description: ''No PharoEDA applications registered'' ]
    ifNotEmpty: [ :apps |
      root
        label: ''PharoEDA application(s)'' translated , '': ''
               , apps size printString; translated;
        description: ''Registered PharoEDA applications'';
        noOrdering.
        apps do: [ :app |
          self edaSettingsOn: aBuilder for: app under: rootSymbol ] ]
'
    classified: 'settings'
#+end_src

However, the old *edaSettings:* method uses a fixed symbol to place the application settings in the tree. Let's fix that.

#+begin_src
EDASettings class>>edaSettingsOn: aBuilder for: anEDAApplication under: aSymbol
  | parent parentGroup |
  parent := anEDAApplication applicationName.
  parentGroup := aBuilder group: parent.
  parentGroup
    label: parent translated;
    parent: aSymbol;
    description: parent;
    noOrdering.
  self
    environmentSettingsOn: aBuilder
    under: parent
    on: anEDAApplication.
  self
    commandListenerSettingsOn: aBuilder
    under: parent
    on: anEDAApplication.
  self
    eventPublisherSettingsOn: aBuilder
    under: parent
    on: anEDAApplication.
  self
    eventStoreSettingsOn: aBuilder
    under: parent
    on: anEDAApplication.
  self
    projectionSettingsOn: aBuilder
    under: parent
    populatedWithValuesFrom: 'projections'
    on: anEDAApplication.
  self loggingSettingsOn: aBuilder under: parent on: anEDAApplication.
  self portSettingsOn: aBuilder under: parent on: anEDAApplication
#+end_src

As you can see, we've renamed the previous methods from *[xxx]SettingsOn: aBuilder under: aSymbol* to *[xxx]SettingsOn: aBuilder: under: aSymbol on: anEDAApplication*. To display and manage each application's settings, we need the application instance. Previously, we used class-scoped attributes of predefined classes as settings. Now we're going to access them through the application instance itself.

* Ports and adapters

We might just add the settings as instance attributes of the =EDAApplication= itself. Such solution would not be flexible enough.
To accomodate different implementations, we can abstract them as a Port. =EDAApplication= instances will include a reference to a port, regardless of the actual implementation used.

The required ports are: environment, command listener, event publisher, event store, projections, and logging.

** Minimal behavior shared among all  Settings Ports

Even though in Smalltalk there's no such thing as an interface (a definition of the contract exposed by all implementations), we'd like to ensure all adapters share certain behavior. For that, we'll use a trait.

#+begin_src
Trait named: #EDATSettingsPort
  uses: {}
  package: 'EDA-Settings-Ports'
#+end_src

The most basic behavior all adapters should support is telling us a brief description of themselves.

#+begin_src
EDATSettingsPort class>>description
  self subclassResponsibility
#+end_src

* Environment setting

This setting is used to identify the environment. Currently, it shows the value of the *PHARO_ENV* environment variable. The first adapter would be one that supports this feature.

If we inspect the current logic used in =EDASettings= to inject the environment setting into de =SettingBrowser= tree, we see the following:

#+begin_src
EDASettings class>>environmentSettingsOn: aBuilder under: aParent on: app
  (aBuilder pickOne: #currentEnvironment)
    parent: aParent;
    target: EDADUEnvironment;
    label: 'Environment' translated;
    description: 'Environment';
    order: 1;
    domainValues:
      (EDADUEnvironment environments
        collect: [ :level | level translated -> level greaseString ]).
#+end_src

The nature of this setting is to choose one of the available environment. It's mainly informative, but it might impose certain restrictions or influence other settings as well.

** Environment variable adapter

As its value is provided by the *PHARO_ENV* environment variable, it cannot be changed. We'll change the ~pickOne:~ above with a simple label, as we did before, when there're no registered applications.

#+begin_src
Object subclass: #EDAEnvironmentSettingsEnvVarAdapter
  uses: EDATSettingsPort
  instanceVariableNames: ''
  lassVariableNames: ''
  package: 'EDA-Settings-Adapters-EnvVars'
#+end_src

Now we need to distinguish between the case in which the value is a single string, and the previous assumption that it'd always be a list of items. A simple way to accomplish it is to ask the port itself. Remember that =EDASettings= relies on =EDAApplication= to provide the settings, and the latter only deals with ports, not adapters. It makes sense to create a new custom =EDATSettingsPort= specifically for the environment-related adapters.

#+begin_src
Trait named: #EDATEnvironmentSettingsPort
  uses: EDATSettingsPort
  package: 'EDA-Settings-Ports'
#+end_src

Of course, we'll use that trait in our current adapter instead of the generic one we were using.

#+begin_src
Object subclass: #EDAEnvironmentSettingsEnvVarAdapter
  uses: EDATEnvironmentSettingsPort
  instanceVariableNames: ''
  lassVariableNames: ''
  package: 'EDA-Settings-Adapters-EnvVars'
#+end_src

This variation can now be accomodated in the new =EDATEnvironmentSettingsPort=.

#+begin_src
EDATEnvironmentSettingsPort>>supportsMultiple
  self subclassResponsibility
#+end_src

Now, =EDASettings= can include both variations:
#+begin_src
EDASettings class>>environmentSettingsOn: aBuilder under: aParent on: app
  | entry port |
  port := app environmentSettingsPort.
  (port supportsMultiple)
    ifTrue: [ entry := aBuilder pickOne: #currentEnvironment.
      entry
        domainValues:
          (EDADUEnvironment environments
            collect: [ :level | level translated -> level greaseString ]) ]
    ifFalse: [ entry := aBuilder setting: #currentEnvironment ].
  entry
    parent: aParent;
    target: aConfig;
    label: aString translated;
    description: aDescription;
    order: 1
#+end_src

=EDAApplication= has to provide an adapter for its ~environmentSettingsPort~ somehow. We'll deal with a mechanism to choose from a list of available adapters soon. For now, let's return the one we've just implemented: =EDAEnvironmentSettingsEnvVarAdapter=.

#+begin_src
EDAApplication>>environmentSettingsPort
  | result |
  result := environmentSettingsPort.
  result ifNil: [
    result := EDAEnvironmentSettingsEnvVarAdapter new.
    self environmentSettingsPort: result
  ].
  ^ result

EDAApplication>>environmentSettingsPort: anAdapter
  anAdapter = environmentSettingsPort
  ifTrue: [ ^ self ].
  environmentSettingsPort := anAdapter
#+end_src

When we launch a =SettingBrowser= we get an =SubclassResponsibility= error. Let's implement it in our adapter. But does it support a list of values? Actually, no. We cannot change the value of the environment value.

#+begin_src
EDAEnvironmentSettingsEnvVarAdapter>>supportsMultiple
  ^ false
#+end_src

Running again =SettingBrowser= will try to call ~currentEnvironment~ on our adapter, but we haven't implemented  it yet. Let's do it now.

#+begin_src
EDAEnvironmentSettingsEnvVarAdapter>>currentEnvironment
  ^ OSPlatform current environment at: 'PHARO_ENV' ifAbsent: '(PHARO_ENV not set)'
#+end_src

=SettingBrowser= should render the tree now, but we're not done yet with this adapter. =EDASettings= assumes the setting can be customized. That is, the adapter supports setting a new value. How can we make it read-only? First of all, =EDASettings= mustn't make any assumption. It's responsibility of the port to provide that information. Based on that, =EDASettings= will choose how to properly display the entry it the tree.

#+begin_src
EDASettings class>>environmentSettingsOn: aBuilder under: aParent on: app
  | entry port |
  port := app environmentSettingsPort.
  (port supportsMultiple)
    ifTrue: [ entry := aBuilder pickOne: #currentEnvironment.
      entry
        domainValues:
          (EDADUEnvironment environments
            collect: [ :level | level translated -> level greaseString ]) ]
    ifFalse: [ (port isReadOnly)
      ifTrue: [ entry := aBuilder group: #currentEnvironment.
        entry dialog: [ LabelMorph newLabel: port currentEnvironment ] ]
      ifFalse: [ entry := aBuilder setting: #currentEnvironment ]
    ].
  entry
    parent: aParent;
    target: aConfig;
    label: aString translated;
    description: aDescription;
    order: 1
#+end_src

So if the port's ~isReadOnly~ returns ~true~, then =EDASettings= will use a =LabelMorph= to display the value provided by the port itself.

We're implementing the ports as traits. It makes sense to indicate all adapters need to override this method.
#+begin_src
EDATEnvironmentSettingsPort>>isReadOnly
  self subclassResponsibility
#+end_src

Our adapter clearly needs to return ~true~:
#+begin_src
EDATEnvironmentSettingsEnvVarAdapter>>isReadOnly
  ^ true
#+end_src

*** Refactoring

Even though our adapter is working, it's not reusable. Every other setting whose value comes from an environment variable would need to share most of its behavior. Before continuing with the next adapter, let's refactor this a bit.

First, let's extract the logic to retrieve values from environment variables into its own trait.

#+begin_src
Trait named: #EDATEnvVarAdapter
  uses: EDATSettingsPort
  package: 'EDA-Settings-Adapters-EnvVars'
#+end_src

#+begin_src
EDATEnvVarAdapter>>getValueFor: envVarName orElse: defaultValue
  ^ OSPlatform current environment
    at: envVarName
    ifAbsent: defaultValue

EDATEnvVarAdapter>>supportsMultiple
  ^ false

EDATEnvVarAdapter>>>>isReadOnly
  ^ true
#+end_src

Our adapter now uses this new trait instead of =EDATSettingsPort=:
#+begin_src
Object subclass: #EDAEnvironmentSettingsEnvVarAdapter
  uses: EDATEnvVarAdapter
  instanceVariableNames: ''
  lassVariableNames: ''
  package: 'EDA-Settings-Adapters-EnvVars'
#+end_src

Finally, the ~currentEnvironment~ implementation delegates the logic to the new trait:

#+begin_src
currentEnvironment
  ^ self
    getValueFor: 'PHARO_ENV'
    orElse: '(PHARO_ENV not set)'
#+end_src

** Predefined list adapter

This adapter allows the user to choose among a predefined list of possible values for the environment setting.
From the point of view of =EDASettings=, if the port supports multiple values, it needs to provide them in advance.

#+begin_src
EDASettings class>>environmentSettingsOn: aBuilder under: aParent on: app
  | entry port |
  port := app environmentSettingsPort.
  (port supportsMultiple)
    ifTrue: [ entry := aBuilder pickOne: #currentEnvironment.
      entry
        domainValues:
          (port availableEnvironments
            collect: [ :level | level translated -> level greaseString ]) ]
    ifFalse: [ (port isReadOnly)
      ifTrue: [ entry := aBuilder group: #currentEnvironment.
        entry dialog: [ LabelMorph newLabel: port currentEnvironment ] ]
      ifFalse: [ entry := aBuilder setting: #currentEnvironment ]
    ].
  entry
    parent: aParent;
    target: aConfig;
    label: aString translated;
    description: aDescription;
    order: 1
#+end_src

For the new adapter, let's create a new package ~EDA-Settings-Adapters-InMemory~ first.

#+begin_src
Object subclass: #EDAPredefinedEnvironmentSettingsInMemoryAdapter
  uses: EDATEnvironmentSettingsPort
  instanceVariableNames: 'currentEnvironment'
  classVariableNames: ''
  package: 'EDA-Settings-Adapters-InMemory'
#+end_src

 It needs to store the selected value in memory.

#+begin_src
EDAPredefinedEnvironmentSettingsInMemoryAdapter>>currentEnvironment
currentEnvironment
  ^ currentEnvironment ifNil: [ self availableEnvironments first ]

EDAPredefinedEnvironmentSettingsInMemoryAdapter>>currentEnvironment: aByteString
  currentEnvironment := aByteString
#+end_src

The list of predefined values is provided by the ~availableEnvironments~ method, used also by =EDASettings=:

#+begin_src
availableEnvironments
  ^ OrderedCollection with: 'dev' with: 'test' with: 'PRO'
#+end_src

We need to tell that the new adapter supports multiple values, so =EDASettings= uses ~pickOne:~ to render the setting.

#+begin_src
supportsMultiple
  ^ true
#+end_src

Also, even though now it's not strictly necessary, this adapter supports read-write values, in case anyone needs to know it.

#+begin_src
isReadOnly
  ^ false
#+end_src

Finally, to test it we can just change =EDAApplication= to use it instead of the current one. We'll introduce a mechanism to inject adapters into ports dynamically soon.

#+begin_src
EDAApplication>>environmentSettingsPort
  | result |
  result := environmentSettingsPort.
  result ifNil: [
    result := EDAPredefinedEnvironmentSettingsInMemoryAdapter new.
    self environmentSettingsPort: result
  ].
  ^ result
#+end_src

*** Refactoring

As we did with the environment-variable adapter, let's introduce a new intermediary trait, common to all "in-memory" adapters, to indicate ~isReadOnly~ is by default ~false~.

#+begin_src
Trait named: #EDATInMemoryAdapter
  uses: EDATSettingsPort
  package: 'EDA-Settings-Adapters-InMemory'
#+end_src

#+begin_src
Object subclass: #EDAPredefinedEnvironmentSettingsInMemoryAdapter
  uses: EDATInMemoryAdapter
  instanceVariableNames: 'currentEnvironment'
  classVariableNames: ''
  package: 'EDA-Settings-Adapters-InMemory'
#+end_src
